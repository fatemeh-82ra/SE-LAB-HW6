<div dir="rtl">

  
  # گزارش فاز اول: سیستم مدیریت هوشمند انرژی

این سند، پیاده‌سازی "سیستم مدیریت پویای مصرف انرژی هوشمند" را تشریح می‌کند. این پروژه به زبان جاوا و با پیروی از متدولوژی توسعه مبتنی بر آزمون (TDD) توسعه یافته است. طراحی اصلی بر پایه الگوهای طراحی **State** و **Strategy** بنا شده تا به ترتیب وضعیت انرژی ساختمان و سیاست‌های محاسبه هزینه را مدیریت کند.

## ۱. پیاده‌سازی الگوهای طراحی
دو الگوی طراحی کلیدی از دسته «رفتاری» (Behavioral) GoF، برای ساختاردهی منطق برنامه به کار گرفته شدند تا از انعطاف‌پذیری و پایبندی به اصول SOLID اطمینان حاصل شود.

### الگوی State
الگوی State یک الگوی طراحی رفتاری است که به یک شیء اجازه می‌دهد وقتی وضعیت داخلی‌اش تغییر می‌کند، رفتارش را نیز تغییر دهد. به نظر می‌رسد که کلاس شیء تغییر کرده است.

* **چرا استفاده شد:** سیستم مدیریت انرژی می‌تواند در یکی از سه وضعیت مجزا باشد: **فعال (Active)**، **اقتصادی (Eco Mode)** یا **خاموش (Shutdown)**. پاسخ سیستم به درخواست‌ها (مانند مشاهده وضعیت) و رفتار ذاتی آن (اینکه کدام دستگاه‌ها روشن/خاموش هستند) مستقیماً به وضعیت فعلی آن بستگی دارد. این الگو از دستورات شرطی بزرگ و یکپارچه (if/else یا switch) در کلاس اصلی (Context) جلوگیری کرده و تمام منطق مربوط به هر وضعیت را به کلاس‌های وضعیت مجزا واگذار می‌کند.

* **چگونه پیاده‌سازی شد:**
    * **واسط `SystemState`:** واسطی که متدهای مشترکی را که تمام وضعیت‌های مشخص باید پیاده‌سازی کنند، تعریف می‌کند (`handleStateChange()` و `getStatus()`).
    * **کلاس‌های وضعیت مشخص:** `ActiveState`، `EcoModeState` و `ShutdownState` پیاده‌سازی‌های مشخص هستند. هر کلاس نسخه مخصوص به خود از متدهای تعریف شده در واسط را ارائه می‌دهد و رفتار مربوط به آن وضعیت خاص را کپسوله می‌کند.
    * **کلاس `BuildingEnergyContext`:** این کلاس یک ارجاع به شیء وضعیت فعلی (`private SystemState currentState`) را نگهداری می‌کند. وقتی متدی مانند `getStatus()` روی این کلاس فراخوانی می‌شود، به سادگی فراخوانی را به شیء وضعیت فعلی واگذار می‌کند. متد `changeState()` مسئول انتقال Context به یک وضعیت جدید است.

### الگوی Strategy
الگوی Strategy یک الگوی طراحی رفتاری است که امکان انتخاب یک الگوریتم در زمان اجرا را فراهم می‌کند. این الگو خانواده‌ای از الگوریتم‌ها را تعریف کرده، هر یک را کپسوله می‌کند و آن‌ها را قابل تعویض می‌سازد.

* **چرا استفاده شد:** سیستم نیاز دارد هزینه‌های انرژی را با استفاده از سیاست‌های مختلف محاسبه کند: **تعرفه معمولی**، **تعرفه ساعات اوج مصرف** و **تعرفه سبز**. این سیاست‌ها می‌توانند در هر زمان توسط مدیر تغییر کنند. الگوی Strategy برای این کار ایده‌آل است، زیرا اجازه می‌دهد الگوریتم محاسبه هزینه به صورت پویا و بدون تغییر کلاس Context که از آن استفاده می‌کند، تعویض شود.

* **چگونه پیاده‌سازی شد:**
    * **واسط `CostCalculationStrategy`:** این واسط یک متد واحد به نام `calculateCost(int energyUnits)` را تعریف می‌کند که به عنوان قرارداد برای تمام الگوریتم‌های قیمت‌گذاری عمل می‌کند.
    * **کلاس‌های Strategy مشخص:** `StandardTariff`، `PeakHoursTariff` و `GreenModeTariff` استراتژی‌های مشخص هستند. هر کلاس متد `calculateCost` را با منطق قیمت‌گذاری خاص خود پیاده‌سازی می‌کند (مثلاً `energyUnits * 500.0` برای تعرفه معمولی).
    * **کلاس `BuildingEnergyContext`:** این کلاس همچنین یک ارجاع به استراتژی فعلی (`private CostCalculationStrategy costStrategy`) را نگهداری می‌کند. متد `setCostStrategy()` به مدیر اجازه می‌دهد این شیء استراتژی را در زمان اجرا تغییر دهد. وقتی متد `simulateCost()` فراخوانی می‌شود، محاسبه را به هر شیء استراتژی که در آن لحظه فعال است، واگذار می‌کند.

## ۲. رویکرد توسعه مبتنی بر آزمون (TDD) 🧪
کل پروژه با پیروی از جریان کاری TDD توسعه یافت تا از صحت و قابلیت نگهداری آن اطمینان حاصل شود. این فرآیند از چرخه **«قرمز-سبز-بازآرایی»** پیروی می‌کند.

**چرخه TDD:**

* **قرمز (RED) - نوشتن یک تست ناموفق:** قبل از نوشتن هرگونه کد پیاده‌سازی، یک تست واحد برای تعریف عملکرد مورد نظر ایجاد شد. به عنوان مثال، تست `testChangeStateFromActiveToEco()` ابتدا نوشته شد. اجرای این تست در ابتدا منجر به شکست می‌شد زیرا متد `changeState` هنوز پیاده‌سازی نشده بود.

   

* **سبز (GREEN) - نوشتن کد برای پاس کردن تست:** حداقل مقدار کد لازم در کلاس‌های `BuildingEnergyContext` و `EcoModeState` نوشته شد تا تست ناموفق، پاس شود. هدف در این مرحله صرفاً رسیدن به نوار «سبز» است، نه نوشتن کد بی‌نقص.
  
<img width="1920" height="1029" alt="Screenshot (2671)" src="https://github.com/user-attachments/assets/234e2eb8-73b4-43f2-8a5d-16b076e73bd4" />
<img width="1920" height="1028" alt="Screenshot (2670)" src="https://github.com/user-attachments/assets/b378ee3b-876f-4e64-ba4f-9f08cd0faaf0" />
<img width="1617" height="995" alt="Screenshot (2686)" src="https://github.com/user-attachments/assets/e27dbc57-790d-4c1f-b651-a6ded4544a2f" />
<img width="1591" height="939" alt="Screenshot (2687)" src="https://github.com/user-attachments/assets/b4b2b20b-fae9-4d24-9681-afa59d4c694c" />

* **بازآرایی (REFACTOR) - تمیز کردن کد:** با داشتن شبکه امنیتی تست‌های پاس شده، کد پیاده‌سازی شده برای بهبود وضوح، کارایی و حذف تکرارها بازبینی و بهبود داده شد، در حالی که اطمینان حاصل می‌شد که تست‌ها همچنان پاس می‌شوند.

این فرآیند برای هر ویژگی، از تغییر وضعیت‌ها گرفته تا محاسبات هزینه، تکرار شد. دو مجموعه تست توسعه داده شد:
* **`BuildingEnergyContextTest`:** تست‌های واحد برای منطق اصلی، تغییر وضعیت‌ها و اجرای استراتژی.
* **`MainTest`:** تست‌های یکپارچه‌سازی برای رابط خط فرمان، شبیه‌سازی ورودی کاربر و تأیید خروجی کنسول برای اطمینان از عملکرد صحیح حلقه برنامه و تعاملات کاربر.
<img width="1919" height="1030" alt="Screenshot (2688)" src="https://github.com/user-attachments/assets/51e5ffc5-6a4b-4b85-85c6-7ba65c4576ce" />
<img width="1920" height="1021" alt="Screenshot (2689)" src="https://github.com/user-attachments/assets/1ef73915-3020-42ee-a799-1574e35a5123" />



</div>


### گزارش بازآرایی فاز دوم

این گزارش به هفت بازآرایی کد انجام شده بر روی پروژه کامپایلر MiniJava می‌پردازد که بر اساس اصول طراحی شیءگرا و کد تمیز صورت گرفته است. هدف هر بازآرایی بهبود ساختار، خوانایی و قابلیت نگهداری پایگاه کد بوده است.

---

### ۱. جایگزینی شرطی با Polymorphism

**مسئله:** متد `semanticFunction` در کلاس `CodeGenerator` شامل یک دستور `switch` بزرگ با ۳۴ حالت بود که یک نمونه کلاسیک از "بوی کد" (code smell) متد طولانی و دستورات `switch` است11. این طراحی، اصل Open/Closed را نقض می‌کند، زیرا افزودن یک عمل معنایی (semantic action) جدید مستلزم تغییر مستقیم در این متد بزرگ است.

**راه‌حل:** دستور `switch` با یک رویکرد چندشکلی جایگزین شد. یک اینترفیس `SemanticAction` ایجاد شد و یک کلاس جداگانه برای هر عمل معنایی پیاده‌سازی گردید. سپس از یک Map برای مرتبط کردن هر شماره عمل با شیء مربوط به آن استفاده شد.

**پیاده‌سازی:** یک اینترفیس `SemanticAction.java` با یک متد `execute()`22 ایجاد شد. یک زیرپکیج جدید به نام `actions` برای نگهداری ۳۴ کلاس ساخته شد که هر کدام اینترفیس `SemanticAction` را پیاده‌سازی کرده و متد مربوط به خود را در `CodeGenerator` فراخوانی می‌کنند33. کلاس `CodeGenerator` بازآرایی شد تا از یک `HashMap` برای ذخیره این اشیای عمل استفاده کند و متد `semanticFunction()` به یک خط واحد ساده شد که عمل صحیح را از map بازیابی و اجرا می‌کند44.

---

### ۲. Extract Class

**مسئله:** کلاس `SymbolTable` یک کلاس بزرگ بود و شامل دو کلاس داخلی پیچیده به نام‌های `Klass` و `Method` بود که انسجام آن را کاهش داده و مدیریت آن را دشوار می‌کرد5.

**راه‌حل:** کلاس‌های داخلی به فایل‌های سطح بالای جداگانه منتقل شدند تا سازماندهی و وضوح پایگاه کد بهبود یابد666.

**پیاده‌سازی:** کلاس داخلی `Klass` در یک فایل جدید به نام `Klass.java` و کلاس داخلی `Method` در یک فایل به نام `Method.java` در پکیج `MiniJava.semantic.symbol` کپی شد7. هر دو کلاس `public` شدند8. سازنده `Method` برای پذیرش یک نمونه `Memory` به عنوان وابستگی به‌روزرسانی شد9. در نهایت، `SymbolTable.java` برای حذف تعریف کلاس‌های داخلی و نمونه‌سازی از کلاس‌های سطح بالای `Klass` و `Method` جدید تغییر یافت10.

---

### ۳. جداسازی Query از Modifier

**مسئله:** کلاس `Memory` شامل متدهایی مانند `getTemp()` و `getDateAddress()` بود که هم یک مقدار را برمی‌گرداندند و هم وضعیت داخلی شیء را تغییر می‌دادند، که این یک نقض کلاسیک اصل جداسازی دستور-پرس‌وجو (Command-Query Separation) است11.

**راه‌حل:** این متدها برای نشان دادن صریح نقش تغییردهنده (modifying) خود تغییر نام یافتند.

**پیاده‌سازی:** متدهای `getTemp()` و `getDateAddress()` در `Memory.java` به ترتیب به `allocateTempAddress()` و `allocateDataAddress()` تغییر نام یافتند12. تمام فراخوانی‌ها به این متدها در `CodeGenerator.java` و `SymbolTable.java` برای استفاده از نام‌های جدید به‌روزرسانی شدند13.

---

### ۴. کپسوله‌سازی فیلد

**مسئله:** کلاس `Address` دارای فیلدهای عمومی (public) مانند `num` و `type` بود که کپسوله‌سازی را نقض کرده و امکان دسترسی کنترل‌نشده از سایر بخش‌های برنامه را فراهم می‌کرد14.

**راه‌حل:** دسترسی به این فیلدها با خصوصی (private) کردن آن‌ها و ارائه متدهای getter عمومی محدود شد.

**پیاده‌سازی:** فیلدهای `num`، `type` و `varType` در `Address.java` به `private` تغییر یافتند15. متدهای عمومی `getNum()`، `getType()` و `getVarType()` اضافه شدند16. تمام کدهای خارجی و داخلی که به طور مستقیم به این فیلدها دسترسی داشتند، برای استفاده از متدهای getter جدید به‌روزرسانی شدند17.

---

### ۵. Replace Magic Number with Symbolic Constant

**توضیح:** کلاس `Memory` از اعداد هاردکد شده مانند ۵۰۰، ۲۰۰ و ۴ برای آدرس‌های حافظه و اندازه کلمه بدون هیچ توضیحی استفاده می‌کرد18. این کار درک کد را دشوار می‌کرد. این بازآرایی این "اعداد جادویی" را با ثابت‌های توصیفی `private static final` جایگزین کرد.

**پیاده‌سازی:** ثابت‌هایی مانند `TEMP_MEM_START_ADDRESS`، `DATA_MEM_START_ADDRESS` و `WORD_SIZE` تعریف و در کلاس `Memory` استفاده شدند19.

---

### ۶. الگوی Facade

**توضیح:** الگوی Facade در دو مورد جداگانه برای ساده‌سازی معماری سیستم با ارائه یک رابط یکپارچه و سطح بالا به زیرسیستم‌های پیچیده، اعمال شد.

**پیاده‌سازی:**

**CompilerFacade:** یک کلاس `CompilerFacade` برای کپسوله‌سازی پیچیدگی نقطه ورود کامپایلر، با پنهان کردن جزئیات نمونه‌سازی پارسر و مدیریت فایل ایجاد شد20. کلاس `Main` به یک فراخوانی واحد به متد `compile()` از facade ساده‌سازی شد21.

**CodeGenerationFacade:** یک کلاس `CodeGenerationFacade` برای کاهش وابستگی پارسر به زیرسیستم پیچیده تولید کد ایجاد شد22. این کلاس با ارائه یک رابط تمیز برای اجرای اعمال معنایی و چاپ کد نهایی، کلاس `Parser` را ساده کرد و جزئیات سطح پایین کلاس‌های `CodeGenerator`، `SymbolTable` و `Memory` را پنهان نمود.
