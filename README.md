<div dir="rtl">

  
  # گزارش فاز اول: سیستم مدیریت هوشمند انرژی

این سند، پیاده‌سازی "سیستم مدیریت پویای مصرف انرژی هوشمند" را تشریح می‌کند. این پروژه به زبان جاوا و با پیروی از متدولوژی توسعه مبتنی بر آزمون (TDD) توسعه یافته است. طراحی اصلی بر پایه الگوهای طراحی **State** و **Strategy** بنا شده تا به ترتیب وضعیت انرژی ساختمان و سیاست‌های محاسبه هزینه را مدیریت کند.

## ۱. پیاده‌سازی الگوهای طراحی
دو الگوی طراحی کلیدی از دسته «رفتاری» (Behavioral) GoF، برای ساختاردهی منطق برنامه به کار گرفته شدند تا از انعطاف‌پذیری و پایبندی به اصول SOLID اطمینان حاصل شود.

### الگوی State
الگوی State یک الگوی طراحی رفتاری است که به یک شیء اجازه می‌دهد وقتی وضعیت داخلی‌اش تغییر می‌کند، رفتارش را نیز تغییر دهد. به نظر می‌رسد که کلاس شیء تغییر کرده است.

* **چرا استفاده شد:** سیستم مدیریت انرژی می‌تواند در یکی از سه وضعیت مجزا باشد: **فعال (Active)**، **اقتصادی (Eco Mode)** یا **خاموش (Shutdown)**. پاسخ سیستم به درخواست‌ها (مانند مشاهده وضعیت) و رفتار ذاتی آن (اینکه کدام دستگاه‌ها روشن/خاموش هستند) مستقیماً به وضعیت فعلی آن بستگی دارد. این الگو از دستورات شرطی بزرگ و یکپارچه (if/else یا switch) در کلاس اصلی (Context) جلوگیری کرده و تمام منطق مربوط به هر وضعیت را به کلاس‌های وضعیت مجزا واگذار می‌کند.

* **چگونه پیاده‌سازی شد:**
    * **واسط `SystemState`:** واسطی که متدهای مشترکی را که تمام وضعیت‌های مشخص باید پیاده‌سازی کنند، تعریف می‌کند (`handleStateChange()` و `getStatus()`).
    * **کلاس‌های وضعیت مشخص:** `ActiveState`، `EcoModeState` و `ShutdownState` پیاده‌سازی‌های مشخص هستند. هر کلاس نسخه مخصوص به خود از متدهای تعریف شده در واسط را ارائه می‌دهد و رفتار مربوط به آن وضعیت خاص را کپسوله می‌کند.
    * **کلاس `BuildingEnergyContext`:** این کلاس یک ارجاع به شیء وضعیت فعلی (`private SystemState currentState`) را نگهداری می‌کند. وقتی متدی مانند `getStatus()` روی این کلاس فراخوانی می‌شود، به سادگی فراخوانی را به شیء وضعیت فعلی واگذار می‌کند. متد `changeState()` مسئول انتقال Context به یک وضعیت جدید است.

### الگوی Strategy
الگوی Strategy یک الگوی طراحی رفتاری است که امکان انتخاب یک الگوریتم در زمان اجرا را فراهم می‌کند. این الگو خانواده‌ای از الگوریتم‌ها را تعریف کرده، هر یک را کپسوله می‌کند و آن‌ها را قابل تعویض می‌سازد.

* **چرا استفاده شد:** سیستم نیاز دارد هزینه‌های انرژی را با استفاده از سیاست‌های مختلف محاسبه کند: **تعرفه معمولی**، **تعرفه ساعات اوج مصرف** و **تعرفه سبز**. این سیاست‌ها می‌توانند در هر زمان توسط مدیر تغییر کنند. الگوی Strategy برای این کار ایده‌آل است، زیرا اجازه می‌دهد الگوریتم محاسبه هزینه به صورت پویا و بدون تغییر کلاس Context که از آن استفاده می‌کند، تعویض شود.

* **چگونه پیاده‌سازی شد:**
    * **واسط `CostCalculationStrategy`:** این واسط یک متد واحد به نام `calculateCost(int energyUnits)` را تعریف می‌کند که به عنوان قرارداد برای تمام الگوریتم‌های قیمت‌گذاری عمل می‌کند.
    * **کلاس‌های Strategy مشخص:** `StandardTariff`، `PeakHoursTariff` و `GreenModeTariff` استراتژی‌های مشخص هستند. هر کلاس متد `calculateCost` را با منطق قیمت‌گذاری خاص خود پیاده‌سازی می‌کند (مثلاً `energyUnits * 500.0` برای تعرفه معمولی).
    * **کلاس `BuildingEnergyContext`:** این کلاس همچنین یک ارجاع به استراتژی فعلی (`private CostCalculationStrategy costStrategy`) را نگهداری می‌کند. متد `setCostStrategy()` به مدیر اجازه می‌دهد این شیء استراتژی را در زمان اجرا تغییر دهد. وقتی متد `simulateCost()` فراخوانی می‌شود، محاسبه را به هر شیء استراتژی که در آن لحظه فعال است، واگذار می‌کند.

## ۲. رویکرد توسعه مبتنی بر آزمون (TDD) 🧪
کل پروژه با پیروی از جریان کاری TDD توسعه یافت تا از صحت و قابلیت نگهداری آن اطمینان حاصل شود. این فرآیند از چرخه **«قرمز-سبز-بازآرایی»** پیروی می‌کند.

**چرخه TDD:**

* **قرمز (RED) - نوشتن یک تست ناموفق:** قبل از نوشتن هرگونه کد پیاده‌سازی، یک تست واحد برای تعریف عملکرد مورد نظر ایجاد شد. به عنوان مثال، تست `testChangeStateFromActiveToEco()` ابتدا نوشته شد. اجرای این تست در ابتدا منجر به شکست می‌شد زیرا متد `changeState` هنوز پیاده‌سازی نشده بود.

   

* **سبز (GREEN) - نوشتن کد برای پاس کردن تست:** حداقل مقدار کد لازم در کلاس‌های `BuildingEnergyContext` و `EcoModeState` نوشته شد تا تست ناموفق، پاس شود. هدف در این مرحله صرفاً رسیدن به نوار «سبز» است، نه نوشتن کد بی‌نقص.
  
<img width="1920" height="1029" alt="Screenshot (2671)" src="https://github.com/user-attachments/assets/234e2eb8-73b4-43f2-8a5d-16b076e73bd4" />
<img width="1920" height="1028" alt="Screenshot (2670)" src="https://github.com/user-attachments/assets/b378ee3b-876f-4e64-ba4f-9f08cd0faaf0" />
<img width="1617" height="995" alt="Screenshot (2686)" src="https://github.com/user-attachments/assets/e27dbc57-790d-4c1f-b651-a6ded4544a2f" />
<img width="1591" height="939" alt="Screenshot (2687)" src="https://github.com/user-attachments/assets/b4b2b20b-fae9-4d24-9681-afa59d4c694c" />

* **بازآرایی (REFACTOR) - تمیز کردن کد:** با داشتن شبکه امنیتی تست‌های پاس شده، کد پیاده‌سازی شده برای بهبود وضوح، کارایی و حذف تکرارها بازبینی و بهبود داده شد، در حالی که اطمینان حاصل می‌شد که تست‌ها همچنان پاس می‌شوند.

این فرآیند برای هر ویژگی، از تغییر وضعیت‌ها گرفته تا محاسبات هزینه، تکرار شد. دو مجموعه تست توسعه داده شد:
* **`BuildingEnergyContextTest`:** تست‌های واحد برای منطق اصلی، تغییر وضعیت‌ها و اجرای استراتژی.
* **`MainTest`:** تست‌های یکپارچه‌سازی برای رابط خط فرمان، شبیه‌سازی ورودی کاربر و تأیید خروجی کنسول برای اطمینان از عملکرد صحیح حلقه برنامه و تعاملات کاربر.
<img width="1919" height="1030" alt="Screenshot (2688)" src="https://github.com/user-attachments/assets/51e5ffc5-6a4b-4b85-85c6-7ba65c4576ce" />
<img width="1920" height="1021" alt="Screenshot (2689)" src="https://github.com/user-attachments/assets/1ef73915-3020-42ee-a799-1574e35a5123" />



</div>


### گزارش بازآرایی فاز دوم

این گزارش به هفت بازآرایی کد انجام شده بر روی پروژه کامپایلر MiniJava می‌پردازد که بر اساس اصول طراحی شیءگرا و کد تمیز صورت گرفته است. هدف هر بازآرایی بهبود ساختار، خوانایی و قابلیت نگهداری پایگاه کد بوده است.

---

### ۱. جایگزینی شرطی با Polymorphism

**مسئله:** متد `semanticFunction` در کلاس `CodeGenerator` شامل یک دستور `switch` بزرگ با ۳۴ حالت بود که یک نمونه کلاسیک از "بوی کد" (code smell) متد طولانی و دستورات `switch` است11. این طراحی، اصل Open/Closed را نقض می‌کند، زیرا افزودن یک عمل معنایی (semantic action) جدید مستلزم تغییر مستقیم در این متد بزرگ است.

**راه‌حل:** دستور `switch` با یک رویکرد چندشکلی جایگزین شد. یک اینترفیس `SemanticAction` ایجاد شد و یک کلاس جداگانه برای هر عمل معنایی پیاده‌سازی گردید. سپس از یک Map برای مرتبط کردن هر شماره عمل با شیء مربوط به آن استفاده شد.

**پیاده‌سازی:** یک اینترفیس `SemanticAction.java` با یک متد `execute()`22 ایجاد شد. یک زیرپکیج جدید به نام `actions` برای نگهداری ۳۴ کلاس ساخته شد که هر کدام اینترفیس `SemanticAction` را پیاده‌سازی کرده و متد مربوط به خود را در `CodeGenerator` فراخوانی می‌کنند33. کلاس `CodeGenerator` بازآرایی شد تا از یک `HashMap` برای ذخیره این اشیای عمل استفاده کند و متد `semanticFunction()` به یک خط واحد ساده شد که عمل صحیح را از map بازیابی و اجرا می‌کند44.

---

### ۲. Extract Class

**مسئله:** کلاس `SymbolTable` یک کلاس بزرگ بود و شامل دو کلاس داخلی پیچیده به نام‌های `Klass` و `Method` بود که انسجام آن را کاهش داده و مدیریت آن را دشوار می‌کرد5.

**راه‌حل:** کلاس‌های داخلی به فایل‌های سطح بالای جداگانه منتقل شدند تا سازماندهی و وضوح پایگاه کد بهبود یابد666.

**پیاده‌سازی:** کلاس داخلی `Klass` در یک فایل جدید به نام `Klass.java` و کلاس داخلی `Method` در یک فایل به نام `Method.java` در پکیج `MiniJava.semantic.symbol` کپی شد7. هر دو کلاس `public` شدند8. سازنده `Method` برای پذیرش یک نمونه `Memory` به عنوان وابستگی به‌روزرسانی شد9. در نهایت، `SymbolTable.java` برای حذف تعریف کلاس‌های داخلی و نمونه‌سازی از کلاس‌های سطح بالای `Klass` و `Method` جدید تغییر یافت10.

---

### ۳. جداسازی Query از Modifier

**مسئله:** کلاس `Memory` شامل متدهایی مانند `getTemp()` و `getDateAddress()` بود که هم یک مقدار را برمی‌گرداندند و هم وضعیت داخلی شیء را تغییر می‌دادند، که این یک نقض کلاسیک اصل جداسازی دستور-پرس‌وجو (Command-Query Separation) است11.

**راه‌حل:** این متدها برای نشان دادن صریح نقش تغییردهنده (modifying) خود تغییر نام یافتند.

**پیاده‌سازی:** متدهای `getTemp()` و `getDateAddress()` در `Memory.java` به ترتیب به `allocateTempAddress()` و `allocateDataAddress()` تغییر نام یافتند12. تمام فراخوانی‌ها به این متدها در `CodeGenerator.java` و `SymbolTable.java` برای استفاده از نام‌های جدید به‌روزرسانی شدند13.

---

### ۴. کپسوله‌سازی فیلد

**مسئله:** کلاس `Address` دارای فیلدهای عمومی (public) مانند `num` و `type` بود که کپسوله‌سازی را نقض کرده و امکان دسترسی کنترل‌نشده از سایر بخش‌های برنامه را فراهم می‌کرد14.

**راه‌حل:** دسترسی به این فیلدها با خصوصی (private) کردن آن‌ها و ارائه متدهای getter عمومی محدود شد.

**پیاده‌سازی:** فیلدهای `num`، `type` و `varType` در `Address.java` به `private` تغییر یافتند15. متدهای عمومی `getNum()`، `getType()` و `getVarType()` اضافه شدند16. تمام کدهای خارجی و داخلی که به طور مستقیم به این فیلدها دسترسی داشتند، برای استفاده از متدهای getter جدید به‌روزرسانی شدند17.

---

### ۵. Replace Magic Number with Symbolic Constant

**توضیح:** کلاس `Memory` از اعداد هاردکد شده مانند ۵۰۰، ۲۰۰ و ۴ برای آدرس‌های حافظه و اندازه کلمه بدون هیچ توضیحی استفاده می‌کرد18. این کار درک کد را دشوار می‌کرد. این بازآرایی این "اعداد جادویی" را با ثابت‌های توصیفی `private static final` جایگزین کرد.

**پیاده‌سازی:** ثابت‌هایی مانند `TEMP_MEM_START_ADDRESS`، `DATA_MEM_START_ADDRESS` و `WORD_SIZE` تعریف و در کلاس `Memory` استفاده شدند19.

---

### ۶. الگوی Facade

**توضیح:** الگوی Facade در دو مورد جداگانه برای ساده‌سازی معماری سیستم با ارائه یک رابط یکپارچه و سطح بالا به زیرسیستم‌های پیچیده، اعمال شد.

**پیاده‌سازی:**

**CompilerFacade:** یک کلاس `CompilerFacade` برای کپسوله‌سازی پیچیدگی نقطه ورود کامپایلر، با پنهان کردن جزئیات نمونه‌سازی پارسر و مدیریت فایل ایجاد شد20. کلاس `Main` به یک فراخوانی واحد به متد `compile()` از facade ساده‌سازی شد21.

**CodeGenerationFacade:** یک کلاس `CodeGenerationFacade` برای کاهش وابستگی پارسر به زیرسیستم پیچیده تولید کد ایجاد شد22. این کلاس با ارائه یک رابط تمیز برای اجرای اعمال معنایی و چاپ کد نهایی، کلاس `Parser` را ساده کرد و جزئیات سطح پایین کلاس‌های `CodeGenerator`، `SymbolTable` و `Memory` را پنهان نمود.




### پرسش‌ها و پاسخ‌ها

---

### ۱. دسته‌بندی الگوهای طراحی (Design Patterns)

الگوهای طراحی به سه دسته اصلی طبقه‌بندی می‌شوند:

* **الگوهای ساختاری (Structural Patterns):** این الگوها با ترکیب کلاس‌ها و اشیا، ساختارهای بزرگ‌تر و پیچیده‌تر را ایجاد می‌کنند.
* **الگوهای سازنده (Creational Patterns):** هدف این الگوها مستقل کردن فرآیند ساخت اشیا از کلاینت است.
* **الگوهای رفتاری (Behavioral Patterns):** این الگوها به مدیریت روابط و مسئولیت‌های بین اشیا می‌پردازند.

---

### ۲. الگوهای رفتاری در فاز اول

الگوهای استفاده‌شده در فاز اول آزمایشگاه، یعنی الگوهای **State** و **Strategy**، هر دو در دسته **رفتاری** (Behavioral) قرار می‌گیرند. این الگوها به نحوه تعامل اشیا و کلاس‌ها با یکدیگر و توزیع مسئولیت‌ها مربوط می‌شوند.

---

### ۳. الگوهای طراحی برای سیستم مدیریت انرژی

الگوهای **State** و **Strategy** هر دو برای مدیریت تغییرات پویا در سیستم هوشمند مدیریت انرژی مناسب هستند:

* **الگوی State برای وضعیت سیستم:** این الگو برای مدیریت وضعیت‌هایی مانند "فعال"، "حالت صرفه‌جویی" و "خاموش" ایده‌آل است. با تغییر وضعیت، رفتار سیستم (مثلاً روشن بودن دستگاه‌ها) نیز تغییر می‌کند و این الگوی از استفاده از شرط‌های طولانی (if-else) جلوگیری می‌کند.
* **الگوی Strategy برای سیاست هزینه:** این الگو برای مدیریت سیاست‌های متغیر محاسبه هزینه (مانند تعرفه "معمولی"، "ساعات اوج مصرف" و "حالت سبز") بهترین انتخاب است. هر تعرفه به عنوان یک استراتژی مجزا پیاده‌سازی می‌شود، که به سیستم اجازه می‌دهد بدون تغییر در کد سمت کلاینت، الگوریتم محاسبه هزینه را تغییر دهد.

---

### ۴. اصول SOLID و الگوی Factory Method

الگوی **Factory Method** به طور کلی با اصول **SOLID** سازگار است:

* **SRP:** کارخانه تنها مسئول ایجاد اشیا است و این اصل را رعایت می‌کند.
* **اصل باز-بسته (OCP):** این الگو به خوبی از OCP پیروی می‌کند؛ افزودن یک محصول جدید تنها با تعریف یک کلاس جدید امکان‌پذیر است، بدون تغییر کد موجود.
* **اصل جایگزینی لیسکوف (LSP):** محصولات ساخته‌شده توسط کارخانه باید با نوع والد خود جایگزین‌پذیر باشند، که این اصل را تضمین می‌کند.
* **اصل تفکیک اینترفیس (ISP):** اینترفیس کارخانه ساده و مختص به ایجاد محصولات است که این اصل را رعایت می‌کند.
* **DIP:** این الگو با وابسته کردن کد سطح بالا و پایین به یک انتزاع (اینترفیس)، DIP را ترویج می‌دهد.

---

### ۵. مفاهیم کد تمیز، بدهی فنی و بوی بد کد

* **کد تمیز (Clean Code):** کدی که خواندن، درک، نگهداری و تغییر آن آسان است، در عین حال که قوی و ایمن باقی می‌ماند.
* **بدهی فنی (Technical Debt):** نتیجه انتخاب یک راه حل سریع و آسان به جای بهترین راه حل است. این بدهی در آینده با نیاز به بازنگری و اصلاح کد "پرداخت" خواهد شد.
* **بوی بد کد (Code Smell):** نشانه‌ای از مشکلات عمیق‌تر در طراحی یا پیاده‌سازی کد که اغلب ناشی از برنامه‌نویسی نادرست است.

---

### ۶. دسته‌بندی بوهای کد

بوهای کد به پنج دسته اصلی تقسیم می‌شوند:

* **Bloaters :** ساختارهای کدی که بیش از حد بزرگ شده‌اند (مانند کلاس‌ها یا متدهای بزرگ).
* **Object-Orientation Abusers :** نقض اصول اساسی برنامه‌نویسی شیءگرا.
* **Change Preventers (موانع تغییر):** بوهایی که ایجاد تغییر در کد را دشوار می‌کنند.
* **Dispensables (قابل‌حذف‌ها):** عناصری که هیچ کاربردی ندارند و می‌توان آن‌ها را حذف کرد.
* **Couplers :** وابستگی بیش از حد بین کلاس‌ها یا ماژول‌ها.

---

### ۷. Feature Envy

* **Feature Envy** در دسته **Couplers** قرار می‌گیرد.
* بازآرایی‌های پیشنهادی برای رفع آن شامل **انتقال متد (Move Method)**، **انتقال فیلد (Move Field)** و **استخراج متد (Extract Method)** است.

---

### ۹. افزونه‌ی قالب‌بندی و بازآرایی کد

یک **افزونه‌ی قالب‌بندی (Formatter Plugin)** ابزاری است که به طور خودکار سبک کد را یکنواخت می‌کند. این افزونه با استانداردسازی ظاهر کد، به شناسایی **بوهای کد** کمک می‌کند و تضمین می‌کند که بازآرایی‌های اصلی به جای تغییرات منطقی، فقط تغییرات ظاهری ناخواسته ایجاد نکنند. این ابزار با حذف شلوغی‌های بصری، تمرکز را بر روی مشکلات طراحی عمیق‌تر حفظ می‌کند و به روند بازآرایی کمک می‌نماید.
